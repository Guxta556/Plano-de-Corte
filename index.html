<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Cutting Plan Optimizer</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <h1>Plano de Corte</h1>
  <form id="cutting-form">
    <div class="form-section">
      <label for="sheet-width">Largura da chapa (cm):</label>
      <input type="number" id="sheet-width" value="100" step="0.1">
    </div>
    <div class="form-section">
      <label for="sheet-height">Altura da chapa (cm):</label>
      <input type="number" id="sheet-height" value="100" step="0.1">
    </div>
    <div class="form-section">
      <label for="border-thickness">Espessura da borda (cm):</label>
      <input type="number" id="border-thickness" value="0.2" step="0.1">
    </div>
    <h2 class="section-title">Adicionar Recorte</h2>
    <div class="form-section">
      <label for="cut-name">Nome do recorte:</label>
      <input type="text" id="cut-name">
    </div>
    <div class="form-section">
      <label for="cut-length">Largura do recorte (cm):</label>
      <input type="number" id="cut-length" step="0.1">
    </div>
    <div class="form-section">
      <label for="cut-width">Altura do recorte (cm):</label>
      <input type="number" id="cut-width" step="0.1">
    </div>
    <div class="form-section">
      <label for="cut-quantity">Quantidade:</label>
      <input type="number" id="cut-quantity" value="1">
    </div>
    <div class="form-section">
      <label for="border-tape">Gerar fita de borda?</label>
      <input type="checkbox" id="border-tape">
    </div>
    <div class="form-section border-selector" id="border-selector" style="display: none;">
      <div class="top" data-border="top"></div>
      <div class="right" data-border="right"></div>
      <div class="bottom" data-border="bottom"></div>
      <div class="left" data-border="left"></div>
    </div>
    <div class="form-section">
      <label for="cut-color">Cor do recorte:</label>
      <input type="color" id="cut-color" value="#0000ff">
    </div>
    <div class="button-group">
      <button type="button" id="add-item">Adicionar Item</button>
      <button type="submit">Gerar Plano de Corte</button>
      <button type="button" id="download">Baixar Plano e Relatório</button>
    </div>
    <ul id="cut-list"></ul>
  </form>
  <canvas id="canvas" width="1000" height="1000"></canvas>



  <script>
    let sheetWidth = 100; // em cm
    let sheetHeight = 100; // em cm
    let borderThickness = 0.2; // em cm
    let cuts = [];
    let ctx;
    const CM_TO_PX = 10; // Conversão de centímetros para pixels

    document.addEventListener("DOMContentLoaded", function() {
      ctx = document.getElementById('canvas').getContext('2d');
    });

    // Função para adicionar um novo recorte
    function addCut() {
      let cutName = document.getElementById('cut-name').value;
      let cutLength = parseFloat(document.getElementById('cut-length').value);
      let cutWidth = parseFloat(document.getElementById('cut-width').value);
      let cutQuantity = parseInt(document.getElementById('cut-quantity').value);
      let cutColor = document.getElementById('cut-color').value;
      let borderTape = document.getElementById('border-tape').checked;
      let selectedBorders = [];
      document.querySelectorAll('.border-selector div.selected').forEach(div => {
        selectedBorders.push(div.getAttribute('data-border'));
      });

      for (let i = 0; i < cutQuantity; i++) {
        cuts.push({ name: cutName, length: cutLength, width: cutWidth, color: cutColor, borderTape, borders: selectedBorders });
      }

      updateCutList();
    }

    // Função para atualizar a lista de recortes
    function updateCutList() {
      let cutList = document.getElementById('cut-list');
      cutList.innerHTML = '';

      cuts.forEach((cut) => {
        let listItem = document.createElement('li');
        listItem.textContent = `${cut.name} - ${cut.length}x${cut.width} - ${cut.color} - ${cut.borderTape ? 'Fita de Borda' : 'Sem Fita de Borda'} - Bordas: ${cut.borders.join(', ')}`;
        cutList.appendChild(listItem);
      });
    }

    
    // Função para organizar os recortes na chapa
    function organizeCuts() {
      // Ordenar os recortes por área decrescente
      cuts.sort((a, b) => b.length * b.width - a.length * a.width);

      let occupiedSpaces = [];
      let totalCutArea = 0;
      let totalBorderLength = 0;

      // Inicializar a posição do recorte atual
      for (let cut of cuts) {
        let position = findPositionForCut(cut, occupiedSpaces);
        if (position) {
          drawCut(position.x, position.y, cut.length, cut.width, cut.name, cut.color, cut.borderTape, cut.borders);
          totalCutArea += cut.length * cut.width;
          occupiedSpaces.push({ x: position.x, y: position.y, width: cut.length + borderThickness, height: cut.width + borderThickness });
          
          if (cut.borderTape) {
            for (let border of cut.borders) {
              switch (border) {
                case 'top':
                case 'bottom':
                  totalBorderLength += cut.length;
                  break;
                case 'left':
                case 'right':
                  totalBorderLength += cut.width;
                  break;
              }
            }
          }
        } else {
          alert(`Não há espaço na chapa para o recorte ${cut.name} considerando a espessura da borda!`);
        }
      }

      let totalRemainingArea = (sheetWidth * sheetHeight) - totalCutArea;
      return { totalCutArea, totalRemainingArea, totalBorderLength };
    }

    // Função para encontrar a posição para o recorte
    function findPositionForCut(cut, occupiedSpaces) {
      for (let y = 0; y <= sheetHeight - cut.width; y += 0.1) {
        for (let x = 0; x <= sheetWidth - cut.length; x += 0.1) {
          if (isPositionValid(x, y, cut.length, cut.width, occupiedSpaces)) {
            return { x: x, y: y, rotated: false };
          } else if (isPositionValid(x, y, cut.width, cut.length, occupiedSpaces)) {
            // Tentar a rotação
            return { x: x, y: y, rotated: true };
          }
        }
      }
      return null;
    }


    // Função para verificar se a posição é válida
    function isPositionValid(x, y, cutLength, cutWidth, occupiedSpaces) {
      for (let space of occupiedSpaces) {
        // Ajuste a verificação da posição se a espessura da borda for zero
        if (borderThickness > 0) {
          if (!(x + cutLength + borderThickness <= space.x || 
                x >= space.x + space.width || 
                y + cutWidth + borderThickness <= space.y || 
                y >= space.y + space.height)) {
            return false;
          }
        } else {
          if (!(x + cutLength <= space.x || 
                x >= space.x + space.width || 
                y + cutWidth <= space.y || 
                y >= space.y + space.height)) {
            return false;
          }
        }
      }
      return true;
    }

    
    /*
    // Função para desenhar um recorte na chapa
    function drawCut(x, y, length, width, name) {
      ctx.fillStyle = document.getElementById('cut-color').value; // Usa a cor selecionada
      ctx.fillRect(x * CM_TO_PX, y * CM_TO_PX, length * CM_TO_PX, width * CM_TO_PX);

      if (borderThickness > 0) {
        ctx.strokeStyle = 'red'; // Cor da borda
        ctx.lineWidth = borderThickness * CM_TO_PX; // Converte cm para pixels
        ctx.strokeRect(x * CM_TO_PX, y * CM_TO_PX, length * CM_TO_PX, width * CM_TO_PX);
      }

      // Adicionar texto ao recorte
      ctx.font = '24px serif';
      ctx.fillStyle = 'black';
      ctx.fillText(name, x * CM_TO_PX + 5, y * CM_TO_PX + 25);
    }

    let borderTapes = {}; // Armazena as bordas para fita de borda selecionadas
    let borderTapeLengths = {}; // Armazena o comprimento total da fita de borda para cada recorte
    */


    // Função para desenhar um recorte na chapa
    function drawCut(x, y, length, width, name, color, borderTape, borders) {
      ctx.fillStyle = color;
      ctx.fillRect(x * CM_TO_PX, y * CM_TO_PX, length * CM_TO_PX, width * CM_TO_PX);
      ctx.strokeStyle = 'red';  // Cor da borda
      ctx.lineWidth = borderThickness * CM_TO_PX; // Converte cm para pixels
      ctx.strokeRect(x * CM_TO_PX, y * CM_TO_PX, length * CM_TO_PX, width * CM_TO_PX);

      if (borderTape) {
        ctx.lineWidth = 1; // Largura da linha da fita de borda
        ctx.strokeStyle = 'blue'; // Cor da fita de borda
        borders.forEach(border => {
          switch (border) {
            case 'top':
              ctx.beginPath();
              ctx.moveTo(x * CM_TO_PX, y * CM_TO_PX);
              ctx.lineTo((x + length) * CM_TO_PX, y * CM_TO_PX);
              ctx.stroke();
              break;
            case 'right':
              ctx.beginPath();
              ctx.moveTo((x + length) * CM_TO_PX, y * CM_TO_PX);
              ctx.lineTo((x + length) * CM_TO_PX, (y + width) * CM_TO_PX);
              ctx.stroke();
              break;
            case 'bottom':
              ctx.beginPath();
              ctx.moveTo((x + length) * CM_TO_PX, (y + width) * CM_TO_PX);
              ctx.lineTo(x * CM_TO_PX, (y + width) * CM_TO_PX);
              ctx.stroke();
              break;
            case 'left':
              ctx.beginPath();
              ctx.moveTo(x * CM_TO_PX, (y + width) * CM_TO_PX);
              ctx.lineTo(x * CM_TO_PX, y * CM_TO_PX);
              ctx.stroke();
              break;
          }
        });
      }
    }


    // Função para configurar o seletor de bordas
    function setupBorderSelector() {
      const borderSelector = document.getElementById('border-selector');
      const borderTapeCheckbox = document.getElementById('border-tape');

      borderTapeCheckbox.addEventListener('change', (e) => {
        borderSelector.style.display = e.target.checked ? 'flex' : 'none';
      });

      borderSelector.addEventListener('click', (e) => {
        if (e.target.dataset.border) {
          const border = e.target.dataset.border;
          const isSelected = e.target.classList.toggle('selected');

          if (isSelected) {
            addBorderTape();
          } else {
            const cutName = document.getElementById('cut-name').value;
            borderT
            borderTapes[cutName].delete(border);
            updateBorderSelectorStyles();
          }
        }
      });
    }

    // Função para adicionar fita de borda
    function addBorderTape() {
      const cutName = document.getElementById('cut-name').value;
      const border = document.getElementById('border-selector').querySelector('.selected').dataset.border;

      if (!borderTapes[cutName]) {
        borderTapes[cutName] = new Set();
      }

      borderTapes[cutName].add(border);

      updateBorderSelectorStyles();
    }

    // Função para calcular o comprimento total da fita de borda
    function calculateTotalBorderTapeLength() {
      let totalLength = 0;

      for (let cut of cuts) {
        const borders = borderTapes[cut.name] || new Set();
        let length = 0;

        // Calcula o comprimento da fita de borda para o recorte atual
        if (borders.has('top')) length += cut.length;
        if (borders.has('bottom')) length += cut.length;
        if (borders.has('left')) length += cut.width;
        if (borders.has('right')) length += cut.width;

        borderTapeLengths[cut.name] = length;
        totalLength += length;
      }

      return totalLength;
    }

    // Função para gerar o relatório e baixar a imagem
    function generateReportAndDownload() {
      let { totalCutArea, totalRemainingArea, totalBorderTapeLength } = organizeCuts();

      // Baixar imagem
      let canvas = document.getElementById('canvas');
      let imageUrl = canvas.toDataURL('image/png');
      let link = document.createElement('a');
      link.href = imageUrl;
      link.download = 'plano_de_corte.png';
      link.click();

      // Gerar relatório
      let report = `Área Total dos Recortes: ${totalCutArea.toFixed(2)} cm²\n`;
      report += `Área Restante da Chapa: ${totalRemainingArea.toFixed(2)} cm²\n`;
      report += `Comprimento Total da Fita de Borda: ${totalBorderTapeLength.toFixed(2)} cm\n`;

      let reportBlob = new Blob([report], { type: 'text/plain' });
      let reportLink = document.createElement('a');
      reportLink.href = URL.createObjectURL(reportBlob);
      reportLink.download = 'relatorio_de_corte.txt';
      reportLink.click();
    }


    // Configura os eventos dos botões
    document.getElementById('add-item').addEventListener('click', addCut);
    document.getElementById('cutting-form').addEventListener('submit', (e) => {
      e.preventDefault();
      organizeCuts();
    });



    document.getElementById('add-item').addEventListener('click', addCut);
    document.getElementById('cutting-form').addEventListener('submit', function(event) {
      event.preventDefault();
      const { totalCutArea, totalRemainingArea, totalBorderLength } = organizeCuts();
      alert(`Área Total Cortada: ${totalCutArea} cm²\nÁrea Restante: ${totalRemainingArea} cm²\nComprimento Total da Fita de Borda: ${totalBorderLength} cm`);
    });

    // Chame a função de configuração do seletor de bordas
    setupBorderSelector();

    // Adicionar evento de click ao botão "Adicionar Item"
    document.getElementById('add-item').addEventListener('click', addCut);

    // Adicionar evento de submit ao formulário
    document.getElementById('cutting-form').addEventListener('submit', (e) => {
      e.preventDefault();
      sheetWidth = parseFloat(document.getElementById('sheet-width').value);
      sheetHeight = parseFloat(document.getElementById('sheet-height').value);
      borderThickness = parseFloat(document.getElementById('border-thickness').value);
      document.getElementById('canvas').width = sheetWidth * CM_TO_PX;
      document.getElementById('canvas').height = sheetHeight * CM_TO_PX;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'gray';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      organizeCuts();
    });

    // Adicionar evento de click ao botão "Baixar Plano e Relatório"
    document.getElementById('download').addEventListener('click', generateReportAndDownload);
  </script>
</body>
</html>
