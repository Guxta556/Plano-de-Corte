<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Cutting Plan Optimizer</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <h1>Plano de Corte</h1>
  <form id="cutting-form">
    <div class="form-section">
      <label for="sheet-width">Largura da chapa (cm):</label>
      <input type="number" id="sheet-width" value="100" step="0.1">
    </div>
    <div class="form-section">
      <label for="sheet-height">Altura da chapa (cm):</label>
      <input type="number" id="sheet-height" value="100" step="0.1">
    </div>
    <div class="form-section">
      <label for="border-thickness">Espessura da borda (cm):</label>
      <input type="number" id="border-thickness" value="0.2" step="0.1">
    </div>
    <h2 class="section-title">Adicionar Recorte</h2>
    <div class="form-section">
      <label for="cut-name">Nome do recorte:</label>
      <input type="text" id="cut-name">
    </div>
    <div class="form-section">
      <label for="cut-length">Largura do recorte (cm):</label>
      <input type="number" id="cut-length" step="0.1">
    </div>
    <div class="form-section">
      <label for="cut-width">Altura do recorte (cm):</label>
      <input type="number" id="cut-width" step="0.1">
    </div>
    <div class="form-section">
      <label for="cut-quantity">Quantidade:</label>
      <input type="number" id="cut-quantity" value="1">
    </div>
    <div class="form-section">
      <label for="border-tape">Gerar fita de borda?</label>
      <input type="checkbox" id="border-tape">
    </div>
    <div class="form-section border-selector" id="border-selector" style="display: none;">
      <div class="top" data-border="top"></div>
      <div class="right" data-border="right"></div>
      <div class="bottom" data-border="bottom"></div>
      <div class="left" data-border="left"></div>
    </div>
    <div class="form-section">
      <label for="cut-color">Cor do recorte:</label>
      <input type="color" id="cut-color" value="#0000ff">
    </div>
    <div class="button-group">
      <button type="button" id="add-item">Adicionar Item</button>
      <button type="submit">Gerar Plano de Corte</button>
      <button type="button" id="download">Baixar Plano e Relatório</button>
    </div>
    <ul id="cut-list"></ul>
  </form>
  <canvas id="canvas" width="1000" height="1000"></canvas>

  <script>
    let sheetWidth = 100; // em cm
    let sheetHeight = 100; // em cm
    let borderThickness = 0.2; // em cm
    let cuts = [];
    let ctx;
    const CM_TO_PX = 10; // Conversão de centímetros para pixels

    document.addEventListener("DOMContentLoaded", function() {
      ctx = document.getElementById('canvas').getContext('2d');
    });

    document.getElementById('border-tape').addEventListener('change', function() {
      const borderSelector = document.getElementById('border-selector');
      borderSelector.style.display = this.checked ? 'grid' : 'none';
    });

    document.querySelectorAll('.border-selector div').forEach(div => {
      div.addEventListener('click', function() {
        this.classList.toggle('selected');
      });
    });

    // Função para adicionar um novo recorte
    function addCut() {
      let cutName = document.getElementById('cut-name').value;
      let cutLength = parseFloat(document.getElementById('cut-length').value);
      let cutWidth = parseFloat(document.getElementById('cut-width').value);
      let cutQuantity = parseInt(document.getElementById('cut-quantity').value);
      let cutColor = document.getElementById('cut-color').value;
      let borderTape = document.getElementById('border-tape').checked;
      let selectedBorders = [];
      document.querySelectorAll('.border-selector div.selected').forEach(div => {
        selectedBorders.push(div.getAttribute('data-border'));
      });

      for (let i = 0; i < cutQuantity; i++) {
        cuts.push({ name: cutName, length: cutLength, width: cutWidth, color: cutColor, borderTape, borders: selectedBorders });
      }

      updateCutList();
    }

    // Função para atualizar a lista de recortes
    function updateCutList() {
      let cutList = document.getElementById('cut-list');
      cutList.innerHTML = '';

      cuts.forEach((cut) => {
        let listItem = document.createElement('li');
        listItem.textContent = `${cut.name} - ${cut.length}x${cut.width} - ${cut.color} - ${cut.borderTape ? 'Fita de Borda' : 'Sem Fita de Borda'} - Bordas: ${cut.borders.join(', ')}`;
        cutList.appendChild(listItem);
      });
    }

    // Função para organizar os recortes na chapa
    function organizeCuts() {
      // Ordenar os recortes por área decrescente
      cuts.sort((a, b) => b.length * b.width - a.length * a.width);

      let occupiedSpaces = [];
      let totalCutArea = 0;
      let totalBorderLength = 0;

      // Inicializar a posição do recorte atual
      for (let cut of cuts) {
        let position = findPositionForCut(cut, occupiedSpaces);
        if (position) {
          drawCut(position.x, position.y, cut.length, cut.width, cut.name, cut.color, cut.borderTape, cut.borders);
          totalCutArea += cut.length * cut.width;
          occupiedSpaces.push({ x: position.x, y: position.y, width: cut.length + borderThickness, height: cut.width + borderThickness });
          
          if (cut.borderTape) {
            for (let border of cut.borders) {
              switch (border) {
                case 'top':
                case 'bottom':
                  totalBorderLength += cut.length;
                  break;
                case 'left':
                case 'right':
                  totalBorderLength += cut.width;
                  break;
              }
            }
          }
        } else {
          alert(`Não há espaço na chapa para o recorte ${cut.name} considerando a espessura da borda!`);
        }
      }

      let totalRemainingArea = (sheetWidth * sheetHeight) - totalCutArea;
      return { totalCutArea, totalRemainingArea, totalBorderLength };
    }

    // Função para encontrar a posição para o recorte
    function findPositionForCut(cut, occupiedSpaces) {
      for (let y = 0; y <= sheetHeight - cut.width; y += 0.1) {
        for (let x = 0; x <= sheetWidth - cut.length; x += 0.1) {
          if (isPositionValid(x, y, cut.length, cut.width, occupiedSpaces)) {
            return { x: x, y: y };
          }
        }
      }
      return null;
    }


    // Função para encontrar a posição para o recorte
    function findPositionForCut(cut, occupiedSpaces) {
      for (let y = 0; y <= sheetHeight - cut.width; y += 0.1) {
        for (let x = 0; x <= sheetWidth - cut.length; x += 0.1) {
          if (isPositionValid(x, y, cut.length, cut.width, occupiedSpaces)) {
            return { x: x, y: y, rotated: false };
          } else if (isPositionValid(x, y, cut.width, cut.length, occupiedSpaces)) {
            // Tentar a rotação
            return { x: x, y: y, rotated: true };
          }
        }
      }
      return null;
    }

    // Função para verificar se a posição é válida
    function isPositionValid(x, y, length, width, occupiedSpaces) {
      for (let space of occupiedSpaces) {
        if (x < space.x + space.width && x + length > space.x &&
            y < space.y + space.height && y + width > space.y) {
          return false;
        }
      }
      return x + length <= sheetWidth && y + width <= sheetHeight;
    }

    // Função para verificar se a posição é válida
    function isPositionValid(x, y, cutLength, cutWidth, occupiedSpaces) {
      for (let space of occupiedSpaces) {
        if (!(x + cutLength + borderThickness <= space.x || x >= space.x + space.width || y + cutWidth + borderThickness <= space.y || y >= space.y + space.height)) {
          return false;
        }
      }
      return true;
    }

    // Função para desenhar um recorte na chapa
    function drawCut(x, y, length, width, name, color, borderTape, borders) {
      ctx.fillStyle = color;
      ctx.fillRect(x * CM_TO_PX, y * CM_TO_PX, length * CM_TO_PX, width * CM_TO_PX);
      ctx.strokeStyle = 'red';  // Cor da borda
      ctx.lineWidth = borderThickness * CM_TO_PX; // Converte cm para pixels
      ctx.strokeRect(x * CM_TO_PX, y * CM_TO_PX, length * CM_TO_PX, width * CM_TO_PX);

      if (borderTape) {
        ctx.lineWidth = 1; // Largura da linha da fita de borda
        ctx.strokeStyle = 'blue'; // Cor da fita de borda
        borders.forEach(border => {
          switch (border) {
            case 'top':
              ctx.beginPath();
              ctx.moveTo(x * CM_TO_PX, y * CM_TO_PX);
              ctx.lineTo((x + length) * CM_TO_PX, y * CM_TO_PX);
              ctx.stroke();
              break;
            case 'right':
              ctx.beginPath();
              ctx.moveTo((x + length) * CM_TO_PX, y * CM_TO_PX);
              ctx.lineTo((x + length) * CM_TO_PX, (y + width) * CM_TO_PX);
              ctx.stroke();
              break;
            case 'bottom':
              ctx.beginPath();
              ctx.moveTo((x + length) * CM_TO_PX, (y + width) * CM_TO_PX);
              ctx.lineTo(x * CM_TO_PX, (y + width) * CM_TO_PX);
              ctx.stroke();
              break;
            case 'left':
              ctx.beginPath();
              ctx.moveTo(x * CM_TO_PX, (y + width) * CM_TO_PX);
              ctx.lineTo(x * CM_TO_PX, y * CM_TO_PX);
              ctx.stroke();
              break;
          }
        });
      }
    }

    // Função para baixar o plano e o relatório
    function downloadReport() {
      // Gerar e baixar o relatório
      let report = '';
      let totalCutArea = 0;
      let totalBorderLength = 0;
      
      cuts.forEach(cut => {
        report += `${cut.name} - ${cut.length}x${cut.width} - ${cut.color} - Bordas: ${cut.borders.join(', ')}\n`;
        totalCutArea += cut.length * cut.width;
        if (cut.borderTape) {
          for (let border of cut.borders) {
            switch (border) {
              case 'top':
              case 'bottom':
                totalBorderLength += cut.length;
                break;
              case 'left':
              case 'right':
                totalBorderLength += cut.width;
                break;
            }
          }
        }
      });

      report += `\nÁrea Total Cortada: ${totalCutArea} cm²`;
      report += `\nComprimento Total da Fita de Borda: ${totalBorderLength} cm`;

      // Criar um arquivo de texto para download
      let blob = new Blob([report], { type: 'text/plain' });
      let url = URL.createObjectURL(blob);
      let a = document.createElement('a');
      a.href = url;
      a.download = 'relatorio_corte.txt';
      a.click();
      URL.revokeObjectURL(url);
    }

    document.getElementById('add-item').addEventListener('click', addCut);
    document.getElementById('cutting-form').addEventListener('submit', function(event) {
      event.preventDefault();
      const { totalCutArea, totalRemainingArea, totalBorderLength } = organizeCuts();
      alert(`Área Total Cortada: ${totalCutArea} cm²\nÁrea Restante: ${totalRemainingArea} cm²\nComprimento Total da Fita de Borda: ${totalBorderLength} cm`);
    });

    document.getElementById('download').addEventListener('click', downloadReport);
  </script>
</body>
</html>
